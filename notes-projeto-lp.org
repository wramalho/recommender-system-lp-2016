#+TITLE: Sistema de Recomendação em Racket
#+AUTHOR: Waldo Ramalho

#+BEGIN_QUOTE

"And he was like, "No, no, I really think we ought to do that." And I was like, "We don't have time!" So he wrote it that night."

(Peter Seibel)

#+END_QUOTE



#+BEGIN_QUOTE

"People think that computer science is the art of geniuses but the actual reality is the opposite, just many people doing things that build on eachother, like a wall of mini stones."

(Donald Knuth)
#+END_QUOTE

* Introdução


/Programming Collective Intelligence: Building Smart Web 2.0 Applications/ de Toby Segaran é um nome feliz. Conjura, de modo preciso, os motivos que levam esta introdução ao aprendizado de máquinas a ser tão empolgante: obter conhecimentos novos a partir de fatos compartilhados por um coletivo. 

O que é tão cativante nisto? É que todos os dados são, de certa forma, de pleno conhecimento de todos. Afinal, qualquer um pode, hoje em dia, saber quais páginas seus amigos curtem no Facebook; qualquer site pode conhecer o que seus usuários compram ou acessam. São informações que são ricas e, ao mesmo tempo, inúteis. São inúteis sozinhas, sem serem coletadas e analisadas, mas com o devido tratamento, essas informações batidas podem dar a luz à novos conhecimentos sobre o comportamente, as preferências e as opiniões de vasta quantidade de pessoas.

Este trabalho é uma tentativa de implementar em Racket um sistema de recomendação, originalmente implementado em Python no segundo capítulo do /Programming Collective Intelligence/ (PCI). Ele foi tornado possível a partir do trabalho de muitos: lectures do curso Mining Massive Datasets dos professores Rajaraman e Ullman, de Stanford, a implementação parcial do PCI do blog /I Need Closures/ de Richard Cook, dois papers sobre sistemas de recomendação e, literalmente, centenas de perguntas e respostas no StackOverflow, Reddit e Quora.

O trabalho é estruturado da seguinte forma: (I) explicar os objetivos que pretendo alcançar no desenvolvimento deste código; (II) apresentar os dados empíricos que foram coletados para desafiar a robustez do código que, em sua implementação original, trabalha com dados hipotéticos e limitados; (III) apresentar o código, explicando seu funcionamento e comentando algumas escolhas de seu design; e (IV) apontar possíveis melhorias e desenvolvimentos possíveis do código.


* Objetivos

O código teve três critérios em seu desenvolvimento:

1. Buscar robustez. No PCI e no código de Richard Cook, o sistema de recomedação toma como input um conjunto de preferências limitado no próprio código (através de um dicionário, no PCI, e de uma lista associativa, em Cook). Considerei que isto era insuficiente, e optei por tentar melhorar o programa ao permitir que ele lidasse com diferentes datasets e, preferencialmente, com dados empíricos;

2. Beleza. Acredito que a beleza de um código é uma boa medida, embora não única e, talvez, a mais importante, de sua qualidade. Busquei programar neste sentido, ao evitar o uso de estados, funções e estruturas de dados que não fossem estritamente necessárias para o sistema de recomendações (exceto quando importantes para sua escalabilidade), escrever um código legível tanto em seus comentários quanto na escolha dos nomes e quantidades de parâmetros e procedimentos, seguir o recomendado pelas práticas de estilo em Racket, entre outras abordagens. No entanto, entendo que a beleza é o que mais falta a este trabalho, em uma autocrítica, fruto da óbvia inexperiência e da limitacão de tempo.

3. Modularização e abstração. Busquei trazer os ensinamentos dos capítulos 2 e 3 do /Structure and Interpretation of Computer Programs/ ao código. Um programa modular e com uso de abstrações é mais escalável e mais elegante.


* O sistema de recomendação

Sistemas de recomendação são ubíquos nas tecnologias de informação e comunicação dos últimos vinte anos. Ainda que quando não presentes, o conceito é um trampolim intuitivo para algoritmos e sistemas mais complexos.

Os mecanismos de um sistema de recomendação são diversos, podendo ser classificados em três tipos principais: filtragem colaborativa, baseados no conteúdo e por modelagem de fatores latentes (citation). Cada tipo apresenta vantagens e desvantagens em termos de eficiência computacional, exigência quanto à quantidade ou completude dos dados e quanto à qualidade das recomendações apresentadas aos usuários. Em uma aplicação real, é usual a combinação de diferentes tipos de sistemas (citation).

Usuários (aquele que se relaciona com os items), items (os objetos das recomendações), avaliações (as preferências dos usuários em relação aos items) e as próprias recomendações são os "objetos" ou conceitos pertinentes à um sistema de recomendação típico. 

O sistema de recomendação que iremos implementar, apresentado no PCI, é de filtragem colaborativa baseado nos usuários. Algoritmos de filtragem colaborativa costumam procurar um certo número de usuários e, a partir destes, identificar um conjunto menor /C/ com preferências similares às do usuário /x/. Ele vai operar sobre os items bem avaliados do conjunto /C/ e combiná-los para criar uma lista hierárquica de sugestões para o usuário /x/. 

O primeiro desafio deste tipo de sistema é como representar diferentes usuários e suas preferências. No PCI, a estrutura de dados escolhida foi os /nested dictionaries/, a qual, no Racket, uma escolha natural seriam as /(nested) hash-tables/. Por sua vez, o código de Richard Cook utilizou as /association lists/ (utilizar fonte beautiful racket).

O segundo desafio é determinar como os usuários são similares entre si a partir de suas preferências. A ideia é comparar cada usuário com cada outro usuário, computando uma espécie de ranking ou /score/ de similaridade. Este, por sua vez, pode ser implementado a partir de diversas métricas: distância eucidiana, correlação de Pearson, similaridade jacquartiana, coseno dos ângulos entre os vetores de preferência dos usuários etc. A utilidade deste /score/ de similaridade é que pode ser utilizado em um procedimento para hierarquizar os usuários do conjunto /C/ em relação ao usuário /x/.


** As diferentes implementações

*** Código do Programming Collective Intelligence

Note-se que o dataset de preferências de usuários (o /nested dictionary/ =critics=) é "/hard-coded/" dentro do próprio código.

#+BEGIN_SRC python

# A dictionary of movie critics and their ratings of a small
# set of movies
critics={'Lisa Rose': {'Lady in the Water': 2.5, 'Snakes on a Plane': 3.5,
'Just My Luck': 3.0, 'Superman Returns': 3.5, 'You, Me and Dupree': 2.5,
'The Night Listener': 3.0},
'Gene Seymour': {'Lady in the Water': 3.0, 'Snakes on a Plane': 3.5,
'Just My Luck': 1.5, 'Superman Returns': 5.0, 'The Night Listener': 3.0,
'You, Me and Dupree': 3.5},
'Michael Phillips': {'Lady in the Water': 2.5, 'Snakes on a Plane': 3.0,
'Superman Returns': 3.5, 'The Night Listener': 4.0},
'Claudia Puig': {'Snakes on a Plane': 3.5, 'Just My Luck': 3.0,
'The Night Listener': 4.5, 'Superman Returns': 4.0,
'You, Me and Dupree': 2.5},
'Mick LaSalle': {'Lady in the Water': 3.0, 'Snakes on a Plane': 4.0,
'Just My Luck': 2.0, 'Superman Returns': 3.0, 'The Night Listener': 3.0,
'You, Me and Dupree': 2.0},
'Jack Matthews': {'Lady in the Water': 3.0, 'Snakes on a Plane': 4.0,
'The Night Listener': 3.0, 'Superman Returns': 5.0, 'You, Me and Dupree': 3.5},
'Toby': {'Snakes on a Plane':4.5,'You, Me and Dupree':1.0,'Superman Returns':4.0}}

from math import sqrt
# Returns a distance-based similarity score for person1 and person2
def sim_distance(prefs,person1,person2):
# Get the list of shared_items
si={}
for item in prefs[person1]:
if item in prefs[person2]:
si[item]=1
# if they have no ratings in common, return 0
if len(si)==0: return 0
# Add up the squares of all the differences
sum_of_squares=sum([pow(prefs[person1][item]-prefs[person2][item],2)
for item in prefs[person1] if item in prefs[person2]])

# Returns the Pearson correlation coefficient for p1 and p2
def sim_pearson(prefs,p1,p2):
# Get the list of mutually rated items
si={}
for item in prefs[p1]:
if item in prefs[p2]: si[item]=1
# Find the number of elements
n=len(si)
# if they are no ratings in common, return 0
if n==0: return 0
# Add up all the preferences
sum1=sum([prefs[p1][it] for it in si])
sum2=sum([prefs[p2][it] for it in si])
# Sum up the squares
sum1Sq=sum([pow(prefs[p1][it],2) for it in si])
sum2Sq=sum([pow(prefs[p2][it],2) for it in si])
# Sum up the products
pSum=sum([prefs[p1][it]*prefs[p2][it] for it in si])
# Calculate Pearson score
num=pSum-(sum1*sum2/n)
den=sqrt((sum1Sq-pow(sum1,2)/n)*(sum2Sq-pow(sum2,2)/n))
if den==0: return 0
r=num/den

# Returns the best matches for person from the prefs dictionary.
# Number of results and similarity function are optional params.
def topMatches(prefs,person,n=5,similarity=sim_pearson):
scores=[(similarity(prefs,person,other),other)
for other in prefs if other!=person]
# Sort the list so the highest scores appear at the top
scores.sort( )
scores.reverse( )
return scores[0:n]

# Gets recommendations for a person by using a weighted average
# of every other user's rankings
def getRecommendations(prefs,person,similarity=sim_pearson):
totals={}
simSums={}
for other in prefs:
# don't compare me to myself
if other==person: continue
sim=similarity(prefs,person,other)
# ignore scores of zero or lower
if sim<=0: continue
for item in prefs[other]:
# only score movies I haven't seen yet
if item not in prefs[person] or prefs[person][item]==0:
# Similarity * Score
totals.setdefault(item,0)
totals[item]+=prefs[other][item]*sim
# Sum of similarities
simSums.setdefault(item,0)
simSums[item]+=sim
# Create the normalized list
rankings=[(total/simSums[item],item) for item,total in totals.items( )]
# Return the sorted list
rankings.sort( )
rankings.reverse( )
return rankings



#+END_SRC

*** Código de Richard Cook

Note-se que o código está incompleto em relação ao PCI. Assim como este, o dataset de preferências dos usuários é "/hard-coded/" dentro do próprio código.

#+BEGIN_SRC lisp


(defparameter *RECOMMENDATIONS* 
  '(
    ("Lisa Rose" . (("Lady in the Water" . 2.5) ("Snakes on a Plane" . 3.5) ("Just My Luck" . 3.0) 
                    ("Superman Returns" . 3.5) ("You, Me and Dupree" . 2.5) ("The Night Listener" . 3.0)))
    ("Gene Seymour" . (("Lady in the Water" . 3.0) ("Snakes on a Plane" . 3.5) ("Just My Luck" . 1.5) 
                       ("Superman Returns" . 5.0) ("The Night Listener" . 3.0) ("You, Me and Dupree" . 3.5)))
    ("Michael Phillips" . (("Lady in the Water" . 2.5) ("Snakes on a Plane" . 3.0) 
                           ("Superman Returns" . 3.5) ("The Night Listener" . 4.0)))
    ("Claudia Puig" . (("Snakes on a Plane" . 3.5) ("Just My Luck" . 3.0) ("The Night Listener" . 4.5) 
                       ("Superman Returns" . 4.0) ("You, Me and Dupree" . 2.5)))
    ("Mick LaSalle" . (("Lady in the Water" . 3.0) ("Snakes on a Plane" . 4.0) ("Just My Luck" . 2.0) 
                       ("Superman Returns" . 3.0) ("The Night Listener" . 3.0) ("You, Me and Dupree" . 2.0)))
    ("Jack Matthews" . (("Lady in the Water" . 3.0) ("Snakes on a Plane" . 4.0) ("The Night Listener" . 3.0) 
                        ("Superman Returns" . 5.0) ("You, Me and Dupree" . 3.5)))
    ("Toby" . (("Snakes on a Plane" . 4.5) ("You, Me and Dupree" . 1.0) 
               ("Superman Returns" . 4.0)))))


(defun critics (reviewer &optional movie)
  (labels ((get-movie (ms m)
             (cdr (assoc m ms :test #'equalp))))
    (let ((movies (cdr (assoc reviewer *RECOMMENDATIONS* :test #'equalp))))
      (if movie (get-movie movies movie) movies))))

(defun similar (person1 person2 distance)
  (let* ((movies1 (critics person1))
         (movies2 (critics person2))
         (common-movies (mapcar #'car (intersection movies1 movies2 
                                                    :test #'(lambda (x y) (equalp (car x) (car y)))))))
    (if (null common-movies)
        nil
        (funcall distance person1 person2 common-movies))))

(defun euclidean-distance (person1 person2 common-movies)
  (let* ((sum-of-squares (reduce #'+ (mapcar 
                                      #'(lambda (cm) 
                                          (expt (- (critics person1 cm) (critics person2 cm)) 2)) 
                                      common-movies)))
         (distance (/ 1 (1+ sum-of-squares))))
    distance))

(defun sim-distance (person1 person2)
  (similar person1 person2 #'euclidean-distance))


(defun pearson-distance (person1 person2 common-movies)
  (let* ((n (length common-movies))
         (scores1 (mapcar #'(lambda (x) (critics person1 x)) common-movies))
         (scores2 (mapcar #'(lambda (x) (critics person2 x)) common-movies))
         (sum1 (reduce #'+ scores1))
         (sum2 (reduce #'+ scores2))
         (sum1-sq (reduce #'+ (mapcar #'(lambda (x) (* x x)) scores1)))
         (sum2-sq (reduce #'+ (mapcar #'(lambda (x) (* x x)) scores2)))
         (psum (reduce #'+ (mapcar #'* scores1 scores2)))
         (num (- psum (/ (* sum1 sum2) n)))
         (den (sqrt (* (- sum1-sq (/ (expt sum1 2) n)) (- sum2-sq (/ (expt sum2 2) n))))))
    (if (zerop den) 0 (/ num den))))

(defun sim-pearson (person1 person2)
  (similar person1 person2 #'pearson-distance))
         
(defun top-matches (person &optional (n 5) (similarity #'sim-pearson))
  (let* ((scores (mapcar #'(lambda (x) (cons (funcall similarity person x) x)) 
                         (remove-if #'(lambda (x) (equalp x person)) (mapcar #'car *RECOMMENDATIONS*))))
         (sorted-scores (sort scores #'> :key #'car))
         (len (length sorted-scores)))
    (if (<= len n)
        sorted-scores
        (butlast sorted-scores (- len n)))))


#+END_SRC

*** O meu sistema de recomendação

#+BEGIN_SRC racket


#lang racket

; pacote para parsing de arquivos csv, de autoria de Neil Van Dyke
(require csv-reading)



; arquivo teste 
(define my-file "teste.csv")



; wrapper da função make-csv-reader-maker, que lê arquivos a partir de critérios
(define make-csv-to-recommender-reader
  (make-csv-reader-maker
   '((separator-chars            #\,)
     (strip-leading-whitespace?  . #t)
     (strip-trailing-whitespace? . #t))))

; acesso linha a linha de arquivo. obs: está preparada apenas para um arquivo específico; funcionalidade de teste 
(define next-row
  (make-csv-to-recommender-reader (open-input-file my-file)))



(define (csv-to-assoc-list filename)

  (define preferences-raw (csv->list (make-csv-to-recommender-reader (open-input-file filename))))
  (define header-row (list-tail (list-ref preferences-raw 0) 1))
  
  (for/list ((i (cdr preferences-raw)))
    (cons (car i)
          (map cons header-row (cdr i)))))

(define teste (csv-to-assoc-list my-file))

(define (intersect set1 set2)
  (cond [(empty? set1) '()]
        [(empty? set2) '()]

        [(= (caar set1) (caar set2)) (cons (list (caar set1)
                                                 (+ (cadar set1)
                                                    (cadar set2)))
                                           (intersect (cdr set1) (cdr set2)))]
        [(< (caar set1) (caar set2)) (intersect (cdr set1) set2)]
        [else (intersect set1 (cdr set2))]))

(define avaliação
  (lambda (avaliador [item empty])
    (if (empty? item)
        (cdr (assoc avaliador teste))
        (cdr (assoc item (cdr (assoc avaliador teste)))))))

; o ideal é ter um mapcar. melhorar
(define (similar avaliador1 avaliador2 f-distance)
  (let* ((items1 (avaliação avaliador1))
         (items2 (avaliação avaliador2))
         ; issues possíveis: mapcar, o uso do car como proc, set-intersect
         (items-em-comum (set-intersect (map car items1) (map car items2))))
    (if (empty? items-em-comum) empty
        (f-distance avaliador1 avaliador2 items-em-comum))))

(define teste-items1 (avaliação "user1"))
(define teste-items2 (avaliação "user2"))



(define (reduce op lst)
  (match lst
    ['()             (error "no elements in list")]
    [(list a)         a]
    [(cons hd tl)    (op hd (reduce op tl))]))

(define (euclidean-distance avaliador1 avaliador2 items-em-comum)
  (let* ((sum-of-squares (reduce + (map (lambda (cm)
                                          (expt
                                           (- (string->number (avaliação avaliador1 cm)) (string->number(avaliação avaliador2 cm))) 2))
                                        items-em-comum)))
         (distance (/ 1 (add1 sum-of-squares))))
    distance))


(define (pearson-distance avaliador1 avaliador2 items-em-comum)
  (let* (
         (n (length items-em-comum))
         (scores1 (map string->number (map (lambda (x) (avaliação avaliador1 x)) items-em-comum)))
         (scores2 (map string->number (map (lambda (x) (avaliação avaliador2 x)) items-em-comum)))
         (soma1 (reduce + scores1))
         (soma2 (reduce + scores2))
         (soma1-seq (reduce + (map (lambda (x) (* x x)) scores1)))
         (soma2-seq (reduce + (map (lambda (x) (* x x)) scores2)))
         (psum (reduce + (map * scores1 scores2)))
         (num (- psum (/ (* soma1 soma2) n)))
         (den (sqrt (* (- soma1-seq (/ (expt soma1 2) n)) (- soma2-seq (/ (expt soma2 2) n))))))
    (if (zero? den) 0 (/ num den))))

(define (sim-pearson avaliador1 avaliador2)
  (similar avaliador1 avaliador2 pearson-distance))
         
         

(define (sim-distance avaliador1 avaliador2)
  (similar avaliador1 avaliador2 euclidean-distance))


(define (top-matches userx [n 5] (similarity sim-pearson))
  (let* (
         (scores (map (lambda (x) (cons (similarity userx x) x))
                      (filter-not (lambda (x) (equal? x userx)) (map car teste))))
         (scores-organizados (sort scores > #:key car))
         (len (length scores-organizados)))
    (define (butlast-matches lst [n 1])
  (if (< (length lst) n) empty
      (take lst (- len n))))
      
    (if (<= len n)
        scores-organizados
        (butlast-matches scores-organizados))))




; variável para exemplificar a estrutura de dados perseguida; funcionalidade de testes
(define ideal '( ("user1" . (("A" . 1.0) ("B" . 3.0) ("C" . 4.5)))
                 ("user2" . (("A" . 3.0) ("B" . 2.5) ("C" . 5.0)))))



; devolve sugestões pro usuário (snippet para parte final)
; (format "~a, recomendo que você visite a praia ~a! Bom passeio (:" username recommendation-output)


#+END_SRC


* Sobre os dados

Tanto o código do PCI quanto o código de Richard Cook recebem datasets de recomendações pré-determinados e já estruturados:

Como eu quero que o meu código possa lidar com diferentes datasets, implementei-o de modo a ler os dados em um arquivo .csv e organizá-lo em uma lista associativa (link):


Ponderei algumas opções de estrutura de dados: hash-table, vectors, structs e listas associativas. A última me pareceu a melhor opção, pois vectors tornavam mais complicado acessar as preferências dos diferentes usuários e structs e hash-tables traziam funcionalidades que não seriam utilizadas. 




Explicit Data Gathering: o dataset vai ser obtido por meio de um questionário aos alunos

Dataset: 
1. Pode ser esparso (nem todos os usuários avaliaram todos os produtos)

* Possíveis melhorias e desenvolvimentos

* Conclusão
  

--------------------

* Planning
  
** Fontes


Cook, Richard.'Programming Collective Intelligence' in Common Lisp, Chapter 2. in: *I Need Closures* (blog). Disponível em: <http://i-need-closures.blogspot.com.br/>.

Isinkayer, F.O.; Folajimi, Y.O.; Ojokoh, B.A. "Recommendation Systems: Principles, methods and evaluation" in: *Egyptian Informatics Journal 16 (261-273)*. Cairo: Elsevier, 2015.

Quora Feed sobre Recommender Systems. Disponível em: <https://www.quora.com/topic/Recommender-Systems-1>.

Ridwan, Mahmud. *Predicting Likes:* Inside A Simple Recommendation Engine's Algorithms. Disponível em: <https://www.toptal.com/algorithms/predicting-likes-inside-a-simple-recommendation-engine>.

Segaran, Toby. *Programming Collective Intelligence:* Building Smart Web 2.0 Applications. Cambridge: O'Reilly, 2016.

Ullman, Jeff. *Lecture Notes on Recommendation Systems (Mining Massive Datasets*. Disponível em: <http://infolab.stanford.edu/~ullman/mmds/ch9.pdf>.




*** processar e inserir no texto

Sistema de Rec:
1. Pode ser 1) baseado no conteúdo, 2) colaborativo ou 3) modelagem de fatores latentes

1) Recomendar items ao usuário X similares aos itens que o usuário X avaliou positivamente anteriormente. Vantagens: a) não precisa de dados de outros usuários, b) é útil para usuários com preferências peculiares, c) items impopulares ou novos não são prejudicados pelo sistema. Desvantagens: a) dificuldade em se criar as características apropriadas aos items e às preferências, b) pouca diversidade nas recomendações; c) "cold-start" para os novos usuários.

2)

Precisa de uma métrica de similaridade entre os conjuntos de preferências dos usuários; Capture a intuição de hierarquia de similaridades (e.g. sim(A,C) > sim (A, B)); Saiba lidar com vetores de preferências desiguais;

Opções para a métrica: similaridade jacquartiana, coseno do ângulo entre rA e rB (problema, trata pref. vazias como 0 (sol. normalização das prefs por meio da subtração destas prefs pela média do row)); c a norm. ainda permite a distinção entre "preferências de alta confiança" e as demais. Outra opção: utilizar o conjunto de usuários k que também avaliarem o item i e, a partir daí, fazer recomendação para x (técnica da vizinhança). 

